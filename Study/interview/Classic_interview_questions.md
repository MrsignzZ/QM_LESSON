- <font color="#DDA24A">**H5的优缺点**</font>
  - 优点
    1. 网络标准统一
    2. 多设备跨平台
    3. 更多的多媒体元素
    4. 替代flash
    5. 涉及网站的抓取和索引
  - 缺点
    1. web storage web socket容易被黑客利用
    2. 浏览器支持程度不一样
    3. 浏览器兼容问题 IE9以下

-  <font color="#DDA24A">**Doctype作用**</font>
  - doctype声明指出阅读程序应该用什么规则集来解释文档中的标记。在Web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是W3C所发布的一个文档类型定义（DTD）中包含的规则。

  1. 声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的HTML 文档。

  2. 所谓的标准模式是指，浏览器按 **浏览器支持的最高标准** 解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。 严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行混杂模式则是一种向后兼容的解析方法，说的透明点就是可以实现IE5.5以下版本浏览器的渲染模式。

  3. 浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 ,将使网页进入怪异模式。

-  <font color="#DDA24A">**cookies和webstorage的区别**</font>
  -  大致分为四点：
  1. 存储容量的差异，存储时效差异
    - cookies: 每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉，可以自定义过期的时间
    - Web Storage 存储空间更大，可以达到 5M, sessionStorage 中的  数据在当前浏览器窗口关闭后自动删除， localStorage  持久存储数据，除非主动删除数据
  2. 是否和服务端发生通信
    - Cookie 中的数据会在浏览器和服务器中来回传递。
    - Web Storage 中的数据仅在存在本地，不与服务器发生交互。
  3. 是否可替代
    - Cookie 也是不可以或缺的： Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在
    - Web Storage 仅仅是为了在本地“存储”数据而生。
  4. api的丰富性差异
    - Cookie 需要前端开发者自己封装 setCookie ， getCookie 。
    - Web Storage 提供更多丰富易用的接口，拥有 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。
-  <font color="#DDA24A">**HTML语义化**</font>
  1. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构：~~方便裸奔~~
  2. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
  3. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
  4. 便于团队开发和维护，语义化使得网页更具可读性，是进一步开发网页的必要步骤，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

-  <font color="#DDA24A">**link和@import的区别**</font>
  1. link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。

  2. link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。

  3. link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。

  4. link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。

-  <font color="#DDA24A">**浏览器内核的理解**</font>
  1. 渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
  2. JS引擎：解析和执行 javascript 来实现网页的动态效果。
  最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

-  <font color="#DDA24A">**src与href的区别**</font>
  1. src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。
  2. href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加link
  那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。

-  <font color="#DDA24A">**tilte和alt的区别**</font>
1. title是对图片的描述，alt是在图片不存在时的替换文字；
2. 搜索引擎对图片的判断主要靠的时alt属性。

-  <font color="#DDA24A">**css优先级**</font>
  - 优先级
  1. 同类型，同级别的样式后者先于前者
  2. ID > 类样式 > 标签 > *
  3. 内联>ID选择器>伪类>属性选择器>类选择器>标签选择器>通用选择器(*)>继承的样式

  4. 具体 > 泛化的，特殊性即css优先级
  5. 近的 > 远的 (内嵌样式 > 内部样式表 > 外联样式表)
  内嵌样式：内嵌在元素中，

    <span style="color:red">span</span>
    内部样式表：在页面中的样式，写在<style></style>中的样式
    外联样式表：单独存在一个css文件中，通过link引入或import导入的样式
  6. !important 权重最高，比 inline style 还要高

  - 计算特殊性值
  1. important > 内嵌 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 > 继承 > 通配符

-  <font color="#DDA24A">**null和undefined的区别**</font>

  1. null是一个空的对象，而undefined是一个全局变量的特殊属性。同时，null是JavaScript的保留关键字，而undefined却不是。
  2. 进行数值运算时，null返回值是0，而undefined是NaN。
  3. null==undefined，但是null！===undefined。我是这样理解的:null和undefined都是没有实际的值的，所以null==undefined，而本质上，null是空的对象，undefined是未定义的一个全局属性，所以null！===undefined。

-  <font color="#DDA24A">**new操作符具体干了什么**</font>
  1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型
2. 属性和方法被加入到 this 引用的对象中
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this
```
    var obj  = {};
    obj.__proto__ = Base.prototype;
    Base.call(obj);
```

-  <font color="#DDA24A">**documen.write和 innerHTML 的区别**</font>
  1. document.write 只能重绘整个页面
  2. innerHTML 可以重绘页面的一部分

-  <font color="#DDA24A">**性能优化的方法**</font>
  1. 减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器
  2. 前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数
  3. 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能
  4. 当需要设置的样式很多时设置 className 而不是直接操作 style
  5. 少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作
  6. 避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)
  7. 图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳

-  <font color="#DDA24A">**一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么**</font>
  1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。
  2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
  3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。
  4. 此时，Web 服务器提供资源服务，客户端开始下载资源。

-  <font color="#DDA24A">**H5的离线存储**</font>

  1. 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件

  2. 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

  3. 如何使用：
    页面头部像下面一样加入一个manifest的属性；在cache.manifest文件的编写离线存储的资源，在离线状态时，操作window.applicationCache进行需求实现

  - 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

  - 离线的情况下，浏览器就直接使用离线存储的资源。

